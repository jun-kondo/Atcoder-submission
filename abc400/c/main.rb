#!/usr/bin/env ruby
# frozen_string_literal: true

n = gets.to_i
ans = 0
(1..59).each do |a|
  x = n / (2**a)
  break if x < 1

  result = (1..x).bsearch { |b| (b * b) > x }
  max_b = result.nil? ? x : result - 1

  ans += (max_b + 1) / 2
end
puts ans

# 概要
# 1以上n以下の2^a * b^2を満たす良い整数をカウントする問題
# 制約が10^18なのでaが60ほどで上限になるので1~59の範囲でループしてカウントする
# aの値が固定されれば、b^2の値がわかるので(x),xの平方根の整数を求めて答えに加算する
# (xの平方根の整数以下の整数すべてが条件をみたすため)
# ただし全てカウントすると重複が発生するのでbは奇数のみをカウントする
# たとえば、16は(2^4 * 1^2)、(2^2 * 2*2)ともあらわせるので重複する
# 後者を素因数分解すると2^2 *(1*2 * 1*2)となる。この分解した2は左の項にまとめたほうがよい
# 上記はbが偶数であれば発生するので、 重複を避けるための方法としてbが奇数の場合のみカウントする
#
# Math.sqrt(x).to_iでやりたいことを二分探索で行う
# 2^a * b^2からx = n / 2**aと求められてこれがb^2の値になる。そこからsqrt(x)でbを平方根で求めればよいのだが、\
# sqrtメソッドだと誤差の関係でテストを通らないので、二分探索でb * b > xとなる最小の値を探す
# そこから1を引くとxの平方根以下の整数で一番大きいものをとりだせる
# x = 1のときにbsearchの結果がnilになってしまうのでその場合はxを代入する
# 奇数を数える
# 上記の計算で得られたbをすべてカウントすると重複してしまうため
# (max_b + 1) / 2で奇数だけをカウントしている

#!/usr/bin/env ruby
# frozen_string_literal: true

n, q = gets.split.map(&:to_i)
p2b = (0...n).to_a
b2h = (0...n).to_a
h2b = (0...n).to_a
(0...q).each do
  num, a, b = gets.split.map(&:to_i)
  a -= 1
  case num
  when 1
    b -= 1
    p2b[a] = h2b[b]
  when 2
    b -= 1
    h2b[a], h2b[b] = h2b[b], h2b[a]
    b2h[h2b[a]] = a # a番目の巣が参照している袋の番号の値(左項)にaを代入する
    b2h[h2b[b]] = b # b番目の巣が参照している袋の番号の値(左項)にbを代入する
  else
    puts b2h[p2b[a]] + 1
  end
end

# 鳩 > 袋 > 巣の関係
# 鳩と巣は直接関連していない
# p2b  # 鳩 -> 袋の参照 添字が鳩の番号、値が袋の番号と考える
# b2h  # 袋 -> 巣の参照 添字が袋の番号、値が巣の番号と考える
# h2b  # 巣 -> 袋の参照 添字が巣の番号、値が袋の番号と考える
#
# 1のクエリ(鳩を指定して移す)の場合は袋を移動している
# p2b[a] = h2b[b] # aの鳩が入っている袋の値bの巣に入っている袋の値を代入を実装している
#
# クエリ2は袋->巣, 巣->袋の参照をスワップすることで問題の実装を行っている ( 巣aにいる鳩をすべて巣bへ移動し、巣bにいる鳩をすべて巣aへ移動する )
# 1. 巣aと巣bの値をスワップ
# 2. 巣aの参照先の袋の値にaを代入
# 3. 巣bの参照先の袋の値にbを代入
# クエリ3で鳩の番号で巣の番号を調べるときは, 鳩aが入っている袋(p2b[a])が入っている巣(b2h[p2b[a]])というふうに参照している
